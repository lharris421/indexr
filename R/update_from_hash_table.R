#' Update File Names Based on New Parameters in Adjusted Hash Table
#'
#' This function updates names of existing results by re-hashing each set of
#' parameters with potentially updated values based on adjustments made to a
#' hash table (see \code{?create_hash_table}) by user. It loads RDS files based
#' on their existing hashes, compares to the corresponding entry in a hash table,
#' generates new hashes where needed, and saves the files with the new hashes.
#' The old files are deleted if their hashes differ from the new ones.
#'
#' @param hash_table A file path to a modified hash table generated by \code{create_hash_table}.
#' @param rds_folder A string specifying the directory containing the RDS files associated with the hash table.
#' @param hash_includes_timestamp Logical; if TRUE, timestamps are included in the hash generation.
#' @param ignore_na Logical; if TRUE, NA values are ignored during hash generation.
#' @param alphabetical_order Logical; if TRUE, parameters are sorted alphabetically before hash generation.
#' @param algo Character string specifying the hashing algorithm to use. Default is \code{"xxhash64"}. See \code{?digest}
#'
#' @return The function does not return a value but saves updated RDS files and deletes old files as needed.
#' @export
#'
#' @examples
#' ## Setup
#' tmp_dir <- file.path(tempdir(), "example")
#' dir.create(tmp_dir)
#'
#' ## Save objects
#' obj1 <- rnorm(1000)
#' obj2 <- data.frame(
#'   x = runif(100),
#'   y = "something",
#'   z = rep(c(TRUE, FALSE), 50)
#' )
#' obj3 <- list(obj1, obj2)
#'
#' params1 <- list(
#'   distribution = "normal",
#'   other_params = list(param1 = TRUE, param2 = 1, param3 = NA)
#' )
#' params2 <- list(
#'   distribution = "uniform",
#'   other_params = list(param1 = FALSE, param2 = 2, param3 = "1", param4 = 4)
#' )
#' params3 <- list(
#'   distribution = "composite",
#'   other_params = list(param1 = TRUE, param2 = 3, param3 = 1)
#' )
#'
#' save_objects(tmp_dir, obj1, params1)
#' save_objects(tmp_dir, obj2, params2)
#' save_objects(tmp_dir, obj3, params3)
#'
#' ## Create hash table
#' create_hash_table(tmp_dir, save_path = file.path(tmp_dir, "hash_table.csv"))
#'
#' ## Read in hash table, make a change, and save
#' hash_table <- read.csv(file.path(tmp_dir, "hash_table.csv"))
#' hash_table$distribution <- "something different"
#' write.csv(hash_table, file.path(tmp_dir, "hash_table.csv"))
#'
#' ## See file names before change
#' list.files(tmp_dir)
#'
#' update_from_hash_table(
#'   hash_table = file.path(tmp_dir, "hash_table.csv"),
#'   rds_folder = tmp_dir
#' )
#'
#' ## See difference to before running update_hash_table()
#' list.files(tmp_dir)
#'
#' ## Cleanup
#' unlink(tmp_dir, recursive = TRUE)
#' @seealso [create_hash_table()]
update_from_hash_table <- function(hash_table,
                                   rds_folder,
                                   hash_includes_timestamp = FALSE,
                                   ignore_na = TRUE,
                                   alphabetical_order = TRUE,
                                   algo = "xxhash64") {
  ## Verify folder and inputs
  check_is_directory(rds_folder)
  hash_table <- check_and_fix_extension(hash_table, "csv")
  parameter_files <- list.files(rds_folder, pattern = "_parameters\\.rds$", full.names = TRUE)
  yaml_file      <- file.path(rds_folder, "indexr.yaml")
  has_params     <- length(parameter_files) > 0
  has_yaml       <- file.exists(yaml_file)

  if (has_params && has_yaml) {
    stop("Both parameter RDS files and 'indexr.yaml' found; run update_from_legacy before proceeding.")
  }
  if (!has_params && !has_yaml) {
    stop(glue::glue("No parameter RDS files or 'indexr.yaml' found in folder: {rds_folder}"))
  }

  ## Read updated CSV
  updated_table <- readr::read_csv(hash_table, show_col_types = FALSE)

  if (has_params) {
    ## LEGACY MODE: update via _parameters.rds files
    for (i in seq_len(nrow(updated_table))) {
      row <- updated_table[i, ]
      old_hash <- row$hash
      old_res   <- file.path(rds_folder, paste0(old_hash, ".rds"))
      old_param <- file.path(rds_folder, paste0(old_hash, "_parameters.rds"))

      res_exists <- file.exists(old_res)
      par_exists <- file.exists(old_param)

      if (res_exists && par_exists) {
        parameters_list <- readRDS(old_param)
        updated_params <- parameters_list

        ## Update each CSV column
        for (col in names(row)) {
          if (col == "hash") next
          current <- get_nested_value_from_list(updated_params, col)
          new_val  <- if (is.character(row[[col]])) c_string_to_vector(row[[col]]) else row[[col]]
          if (is.null(current) || all(is.na(current))) {
            if (all(is.na(new_val))) next
          } else {
            new_val <- tryCatch(as(new_val, class(current)), error = function(e) new_val)
            if (identical(current, new_val)) next
          }
          message(glue::glue("Updating '{col}': {current} -> {new_val}"))
          updated_params <- update_nested_list_from_csv(updated_params, col, new_val)
        }

        if (!identical(parameters_list, updated_params)) {
          ## Compute new hash
          new_hash <- generate_hash(
            parameters_list = updated_params,
            hash_includes_timestamp = hash_includes_timestamp,
            ignore_na              = ignore_na,
            alphabetical_order      = alphabetical_order,
            algo                    = algo
          )$hash

          if (!identical(old_hash, new_hash)) {
            new_res   <- file.path(rds_folder, paste0(new_hash, ".rds"))
            new_param <- file.path(rds_folder, paste0(new_hash, "_parameters.rds"))

            if (file.exists(new_res) || file.exists(new_param)) {
              tmp_suf <- paste0("_temp_",
                                paste0(sample(c(0:9, letters, LETTERS), 5, TRUE), collapse = "")
              )
              final_hash <- paste0(new_hash, tmp_suf)
              message(glue::glue("Collision: using '{final_hash}' instead of '{new_hash}'"))
              new_res   <- file.path(rds_folder, paste0(final_hash, ".rds"))
              new_param <- file.path(rds_folder, paste0(final_hash, "_parameters.rds"))
            }

            file.rename(old_res, new_res)
            saveRDS(updated_params, new_param)
            file.remove(old_param)
            message(glue::glue("Rehashed '{old_hash}' -> '{basename(new_res)}'"))
          } else {
            saveRDS(updated_params, old_param)
            message(glue::glue("Parameters updated for '{old_hash}', hash unchanged."))
          }
        } else {
          message(glue::glue("No updates for '{old_hash}'."))
        }

      } else {
        if (!res_exists && !par_exists) {
          warning(glue::glue("Missing both files for hash '{old_hash}', skipping."))
        } else if (!par_exists) {
          warning(glue::glue("Missing parameters for '{old_hash}', skipping."))
        } else {
          warning(glue::glue("Missing results for '{old_hash}', skipping."))
        }
      }
    }

  } else {
    ## YAML MODE: update via indexr.yaml
    index_list <- yaml::read_yaml(yaml_file)

    for (i in seq_len(nrow(updated_table))) {
      row      <- updated_table[i, ]
      old_hash <- row$hash

      if (!old_hash %in% names(index_list)) {
        warning(glue::glue("Hash '{old_hash}' not in YAML index; skipping."))
        next
      }

      params       <- index_list[[old_hash]]
      updated_params <- params

      for (col in names(row)) {
        if (col == "hash") next
        current <- get_nested_value_from_list(updated_params, col)
        new_val  <- if (is.character(row[[col]])) c_string_to_vector(row[[col]]) else row[[col]]
        if (is.null(current) || all(is.na(current))) {
          if (all(is.na(new_val))) next
        } else {
          new_val <- tryCatch(as(new_val, class(current)), error = function(e) new_val)
          if (identical(current, new_val)) next
        }
        message(glue::glue("Updating '{col}' for YAML hash '{old_hash}'"))
        updated_params <- update_nested_list_from_csv(updated_params, col, new_val)
      }

      if (!identical(params, updated_params)) {
        new_hash <- generate_hash(
          parameters_list = updated_params,
          hash_includes_timestamp = hash_includes_timestamp,
          ignore_na              = ignore_na,
          alphabetical_order      = alphabetical_order,
          algo                    = algo
        )$hash

        if (!identical(old_hash, new_hash)) {
          old_file <- file.path(rds_folder, paste0(old_hash, ".rds"))
          new_file <- file.path(rds_folder, paste0(new_hash, ".rds"))

          if (file.exists(new_file) || new_hash %in% names(index_list)) {
            stop(glue::glue(
              "Collision on rehash '{old_hash}' -> '{new_hash}'. Aborting."
            ))
          }

          if (file.exists(old_file)) {
            file.rename(old_file, new_file)
          } else {
            warning(glue::glue(
              "Result file for '{old_hash}' missing; updating YAML only."
            ))
          }

          index_list[[old_hash]] <- NULL
          index_list[[new_hash]] <- updated_params
          message(glue::glue("Rehashed YAML '{old_hash}' -> '{new_hash}'"))
        } else {
          index_list[[old_hash]] <- updated_params
          message(glue::glue("YAML parameters updated for '{old_hash}', hash unchanged."))
        }
      } else {
        message(glue::glue("No changes for YAML hash '{old_hash}'."))
      }
    }

    yaml::write_yaml(index_list, yaml_file)
  }

  invisible()
}
# Function to convert a string back into the original R object
c_string_to_vector <- function(str) {

  if (is.na(str) || str == "") {
    return(NA)
  }

  # Remove leading and trailing whitespace
  str <- trimws(str)

  # Check if the string represents a logical value
  if (str %in% c("TRUE", "FALSE")) {
    return(as.logical(str))
  }

  # Check if the string represents a numeric value
  if (grepl("^-?\\d+\\.?\\d*$", str)) {
    return(as.numeric(str))
  }

  # Check if the string is a vector represented as c(...)
  if (grepl("^c\\(", str) && grepl("\\)$", str)) {
    # Extract the content inside c()
    content <- sub("^c\\((.*)\\)$", "\\1", str)
    # Split the content by commas
    elements <- strsplit(content, ",")[[1]]
    elements <- trimws(elements)

    # Determine the data type of the elements
    if (all(elements %in% c("TRUE", "FALSE"))) {
      return(as.logical(elements))
    } else if (all(grepl("^-?\\d+\\.?\\d*$", elements))) {
      return(as.numeric(elements))
    } else {
      elements <- sub('^"(.*)"$', '\\1', elements)
      return(elements)
    }
  }

  # Return the string as is for character data
  return(str)
}

# Function to update the nested list based on a flattened column name from the CSV
update_nested_list_from_csv <- function(lst, col_name, value) {
  split_names <- unlist(strsplit(col_name, "\\[\\[|\\]\\]"))
  split_names <- split_names[split_names != ""]  # Remove empty strings

  # Recursive function to update the nested list
  set_value <- function(current_list, names_vec, value) {
    name <- names_vec[1]
    if (length(names_vec) == 1) {
      current_list[[name]] <- value
    } else {
      if (is.null(current_list[[name]])) {
        current_list[[name]] <- list()
      }
      current_list[[name]] <- set_value(current_list[[name]], names_vec[-1], value)
    }
    return(current_list)
  }

  lst <- set_value(lst, split_names, value)
  return(lst)
}

# Function to retrieve a nested value from a list based on a flattened column name
get_nested_value_from_list <- function(lst, col_name) {
  split_names <- unlist(strsplit(col_name, "\\[\\[|\\]\\]"))
  split_names <- split_names[split_names != ""]  # Remove empty strings

  # Recursive function to get the nested value
  get_value <- function(current_list, names_vec) {
    name <- names_vec[1]
    if (is.null(current_list[[name]])) {
      return(NULL)
    } else if (length(names_vec) == 1) {
      return(current_list[[name]])
    } else {
      return(get_value(current_list[[name]], names_vec[-1]))
    }
  }

  value <- get_value(lst, split_names)
  return(value)
}

